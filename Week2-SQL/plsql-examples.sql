-------------------------------------
-- WORKING WITH FUNCTIONS
-------------------------------------
-- BEFORE WE CREATE A FUNCTION, NOTE THAT WE CAN EXECUTE BLOCKS OF CODE BETWEEN BEGIN/END KEYWORDS
-- THIS CODE PRINTS TO THE SCRIPT OUTPUT, SO WE NEED TO RUN THIS LINE FIRST
SET SERVEROUTPUT ON;

BEGIN 
    DBMS_OUTPUT.PUT_LINE('HELLO WORLD');
END;
/

-- NOW WE CAN CREATE A FUNCTION
/*
CREATE [OR REPLACE] FUNCTION [FUNCTION NAME][(PARAM1, PARAM2 ...)]
RETURN [RETURN TYPE]
IS
[ANY VARIABLE DECLARATIONS]
BEGIN
//EXECUTABLE CODE
END;
/
*/

-- HELLO WORLD FUNCTION
CREATE OR REPLACE FUNCTION SAY_HI
RETURN VARCHAR2 
IS
BEGIN 
    RETURN 'HELLO WORLD FROM SQL DEVELOPER!!!';
END;
/

-- AFTER RUNNING THE COMMAND ABOVE WILL COMPILE THE FUNCTION
-- WE EXECUTE IT IN THE BLOCK BELOW
BEGIN 
    DBMS_OUTPUT.PUT_LINE(SAY_HI());
END;
/


-- USING A FUNCTION IN A FUNCTION:
CREATE OR REPLACE FUNCTION RETURN_NAME
RETURN VARCHAR2
IS
BEGIN 
    RETURN 'John Smith';
END;
/

-- "RETURN NAME" IS NOT THE MOST PRACTICAL FUNCTION BUT WE CAN SEE THAT IT CAN BE USED IN SELECT CLAUSES BELOW
    -- WE COULD HAVE DONE THIS TO GET THE SALARY MAX VALUE, OR ANY RELEVANT VALUE 
SELECT *
FROM EMPLOYEE
WHERE EMP_NAME = RETURN_NAME();

-- HOW ELSE CAN WE ACCESS THIS FUNCTION?
-- YOU'LL SEE RUNNING THIS COMMAND WILL NOT WORK, 
    -- SO WHAT IF WE WANTED TO GET THE RESULT WITHOUT USING IT IN A QUERY
RETURN_NAME();

-- ALSO WILL NOT WORK BECAUSE WE NEED A FROM CLAUSE IN A SELECT STATEMENT
SELECT RETURN_NAME();

-- THIS IS THE PERFECT USE CASE FOR "DUAL"
    -- DUAL IS A DUMMY TABLE WHICH WE CAN USE IF WE NEED A VALUE OUTSIDE THE CONTEXT OF A REAL QUERY
SELECT RETURN_NAME() FROM DUAL;

SELECT 5 FROM DUAL;

SELECT 5 AS MY_NUM FROM DUAL;

DROP FUNCTION SAY_HI;

-- CREATE A FUNCTION WHICH TAKES A SINGLE NUMERIC INPUT AND RETURNS THE SQUARED VALUE OF THAT NUMBER
CREATE OR REPLACE FUNCTION SQUARE(X IN NUMBER)
RETURN NUMBER
IS
BEGIN
    RETURN X*X;
END;
/

-- WE HAVEN'T YET SEEN DECLARATION IN OUR BLOCKS; WE NEED TO DO THIS AFTER THE DECLARE KEYWORD
    -- BEFORE BEGIN, := ACTS AS THE ASSIGNMENT OPERATOR
DECLARE 
    N NUMBER:=5;
BEGIN
    DBMS_OUTPUT.PUT_LINE(SQUARE(N));
END;
/

SELECT 5 AS MY_NUM, SQUARE(5) AS MY_NUM_SQUARED FROM DUAL;

-- NOT A GREAT USE CASE FOR THIS, BUT WE CAN SEE HOW WE COULD USE IT
SELECT SQUARE(MONTHLY_SALARY)
FROM EMPLOYEE
WHERE EMP_ID=10;

-- DECLARING ADDITIONAL VALUES TO BE USED IN OUR FUNCTION
    -- HERE WE CREATE THE SAME FUNCTION BUT INCLUDE AN ADDITIONAL VARIABLE TO SEE HOW WE DECLARE HELPER VARIABLES
CREATE OR REPLACE FUNCTION SQUARE(X IN NUMBER)
RETURN NUMBER
IS
--ANY OTHER VARIABLES
Y NUMBER;
BEGIN
    Y := X*X;
    RETURN Y;
END;
/

-- FIND MAX BETWEEN TWO NUMERIC VARIABLES
CREATE OR REPLACE FUNCTION FIND_MAX(X NUMBER, Y NUMBER)
RETURN NUMBER
IS
Z NUMBER;
BEGIN 
    IF X>Y THEN
    Z := X;
    ELSE 
    Z := Y;
    END IF;
    RETURN Z;
END;
/

DECLARE 
    FIRST_NUM NUMBER;
    SECOND_NUM NUMBER;
    MAX_NUM NUMBER;
BEGIN 
    FIRST_NUM := 54;
    SECOND_NUM := 32;
    MAX_NUM := FIND_MAX(FIRST_NUM, SECOND_NUM);
    DBMS_OUTPUT.PUT_LINE('MAX: '||MAX_NUM);
END;
/


-- THIS IS A METHOD THAT WOULD CALCULATE SALARIES AFTER INCOME TAX
    -- DOING THIS ROUGHLY WITH 20% TAX
CREATE OR REPLACE FUNCTION APPLY_TAX(PRE_TAX IN NUMBER)
RETURN NUMBER
IS
POST_TAX NUMBER;
BEGIN 
    POST_TAX := (.80)*PRE_TAX;
    RETURN POST_TAX;
END;
/

SELECT EMP_NAME, MONTHLY_SALARY AS PRETAX, APPLY_TAX(MONTHLY_SALARY) AS POSTTAX
FROM EMPLOYEE;

-- CREATING THIS FUNCTION AGAIN MORE ADDITIONAL LOGIC TO DETERMINE TAX RATES
CREATE OR REPLACE FUNCTION APPLY_TAX(PRE_TAX IN NUMBER)
RETURN NUMBER
IS
POST_TAX NUMBER;
BEGIN 
    IF 10000<PRE_TAX THEN
        POST_TAX := (.50)*PRE_TAX;
    ELSIF 3000<PRE_TAX THEN
        POST_TAX := (.71)*PRE_TAX;
    ELSIF 2000<PRE_TAX THEN
        POST_TAX := (.75)*PRE_TAX;
    ELSE 
        POST_TAX := (.78)*PRE_TAX;
    END IF;
    RETURN POST_TAX;
END;
/

-------------------------------------
-- CREATING STORED PROCEDURES
-------------------------------------
CREATE OR REPLACE PROCEDURE SAY_HI_PROCEDURE
IS
BEGIN 
    DBMS_OUTPUT.PUT_LINE('HELLO WORLD');
END;
/

-- UNLIKE FUNCTIONS, STORED PROCEDURES CAN BE CALLED AS STANDALONE ENTITIES 
BEGIN
    SAY_HI_PROCEDURE();
END;
/

-- CREATE A PROCEDURE WHICH HAS AN OUTPUT PARAMETER OF A CURSOR
    -- A CURSOR IS A POINTER TO A CONTEXT AREA, WHICH IS ESSENTIALLY A RESULT SET
    -- IN THIS CASE OUR PROCEDURE WILL BE SAVING THE RESULT OF A QUERY ON OUR EMPLOYEE TABLE INTO OUR CURSOR
    -- CURSORS ARE OFTEN USED TO STORE AND PROCESS QUERIED DATA
CREATE OR REPLACE PROCEDURE GET_ALL_EMPLOYEES(S OUT SYS_REFCURSOR)
IS
BEGIN 
    OPEN S FOR
    SELECT EMP_ID, EMP_NAME FROM EMPLOYEE ORDER BY EMP_ID;
END;
/

-- HERE WE ACCESS THAT CURSOR, ITERATE OVER IT AND PRINT EACH EMPLOYEE TO THE SCRIPT OUTPUT
-- WE MUST DECLARE THE OUTPUT PARAMETER BEFOREHAND, AND THEN AFTER THE STORED PROCEDURE IS EXECUTED, 
    -- THE VARIABLE PASSED IN WILL HOLD THE CALCULATED VALUE
DECLARE
    SVAR SYS_REFCURSOR;
    TEMP_ID EMPLOYEE.EMP_ID%TYPE;
    TEMP_NAME EMPLOYEE.EMP_NAME%TYPE;
BEGIN 
    GET_ALL_EMPLOYEES(SVAR);
    LOOP
        FETCH SVAR INTO TEMP_ID, TEMP_NAME;
        EXIT WHEN SVAR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(TEMP_ID||' IS CURRENT ID, '||TEMP_NAME||' IS CURRENT NAME');
    END LOOP;
    CLOSE SVAR;
END;
/

-- CREATE A STORED PROCEDURE WHICH RETURNS A CURSOR ASSOCIATED WITH A RESULT SET OF EMPLOYEES IN A CERTAIN DEPARTMENT
    -- THE DEPARTMENT NAME IS PASSED IN AS A PARAMETER
CREATE OR REPLACE PROCEDURE GET_FROM_DEPARTMENT(S OUT SYS_REFCURSOR, DEPT IN VARCHAR)
IS
BEGIN 
    OPEN S FOR
        SELECT EMP_ID, EMP_NAME 
        FROM EMPLOYEE 
        WHERE DEPT_ID = 
            (SELECT DEPT_ID
            FROM DEPARTMENT
            WHERE DEPT_NAME = DEPT);
END;
/

DECLARE
    SVAR SYS_REFCURSOR;
    TEMP_ID EMPLOYEE.EMP_ID%TYPE;
    TEMP_NAME EMPLOYEE.EMP_NAME%TYPE;
BEGIN 
    GET_FROM_DEPARTMENT(SVAR,'MARKETING');
    LOOP
        FETCH SVAR INTO TEMP_ID, TEMP_NAME;
        EXIT WHEN SVAR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(TEMP_ID||' IS CURRENT ID, '||TEMP_NAME||' IS CURRENT NAME');
    END LOOP;
    CLOSE SVAR;
END;
/



--UPDATE DEPARTMENT
--SET MONTHLY_BUDGET = MONTHLY_BUDGET + INCREASE_INPUT
--WHERE DEPT_ID = DEPT_INPUT

-- CREATE A PROCEDURE WHICH INCREASES THE BUDGET OF THE DEPARTMENT
CREATE OR REPLACE PROCEDURE INCREASE_BUDGET(DEPT IN DEPARTMENT.DEPT_ID%TYPE, VAL IN DEPARTMENT.MONTHLY_BUDGET%TYPE)
IS
BEGIN
    UPDATE DEPARTMENT
    SET MONTHLY_BUDGET = MONTHLY_BUDGET + VAL
    WHERE DEPT_ID = DEPT;
END;
/

BEGIN 
    INCREASE_BUDGET(1, 8000);
    INCREASE_BUDGET(2, 5000);
    INCREASE_BUDGET(3, 11000);
    INCREASE_BUDGET(5, 16000);
    INCREASE_BUDGET(6, 10000);
    COMMIT;
END;
/


-- THIS QUERY SHOWS US EACH BUDGET, ALONG WITH THE THEIR BUDGET AND THE BUDGET THEY'VE CURRENTLY USED 
SELECT D.DEPT_NAME DEPARTMENT, D.MONTHLY_BUDGET BUDGET, SUM(E.MONTHLY_SALARY) "BUDGET USED"
FROM EMPLOYEE E
JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID
GROUP BY D.DEPT_NAME, D.MONTHLY_BUDGET;

BEGIN 
    INCREASE_BUDGET(2, 1500);
    COMMIT;
END;
/


-- CREATE A STORED PROCEDURE WHICH ALLOWS US TO GIVE AN EMPLOYEE A RAISE
-- BUT ONLY IF THEIR DEPARTMENT HAS THE BUDGET ALLOWED FOR THEIR RAISE AMOUNT 
CREATE OR REPLACE PROCEDURE GIVE_RAISE(INPUT_ID EMPLOYEE.EMP_ID%TYPE, RAISE_AMOUNT EMPLOYEE.MONTHLY_SALARY%TYPE)
IS 
    DEPT_BUDGET DEPARTMENT.MONTHLY_BUDGET%TYPE;
    BUDGET_USED DEPARTMENT.MONTHLY_BUDGET%TYPE;
    EMPLOYEE_NAME EMPLOYEE.EMP_NAME%TYPE;
    CURRENT_SALARY EMPLOYEE.MONTHLY_SALARY%TYPE;
BEGIN
    -- GET THE DEPARTMENT BUDGET 
    SELECT MONTHLY_BUDGET INTO DEPT_BUDGET
    FROM DEPARTMENT
    WHERE DEPT_ID = 
        (SELECT DEPT_ID
        FROM EMPLOYEE
        WHERE EMP_ID = INPUT_ID);
    --DBMS_OUTPUT.PUT_LINE(DEPT_BUDGET);
        
    -- GET THE AGGREGATED SUM OF THE DEPARTMENT'S SALARY 
    SELECT SUM(MONTHLY_SALARY) INTO BUDGET_USED
    FROM EMPLOYEE
    WHERE DEPT_ID = 
        (SELECT DEPT_ID
        FROM EMPLOYEE
        WHERE EMP_ID = INPUT_ID);
    --DBMS_OUTPUT.PUT_LINE(BUDGET_USED);    

    -- ASSIGN VARIABLES FOR THE EMPLOYEE'S NAME AND SALARY
    SELECT EMP_NAME, MONTHLY_SALARY INTO EMPLOYEE_NAME, CURRENT_SALARY
    FROM EMPLOYEE
    WHERE EMP_ID = INPUT_ID;
    -- DBMS_OUTPUT.PUT_LINE('NAME: '||EMPLOYEE_NAME||', SALARY: '||CURRENT_SALARY );   

    -- COMPARE THESE VALUES WITH THE RAISE_AMOUNT
    -- DETERMINE IF THE EMPLOYEE IS ELIGABLE FOR SAID RAISE
    IF((BUDGET_USED+RAISE_AMOUNT)>DEPT_BUDGET) THEN
        DBMS_OUTPUT.PUT_LINE('INSUFFICIENT DEPARTMENT FUNDS. MONTHLY SALARY FOR '||EMPLOYEE_NAME||' REMAINS $'||CURRENT_SALARY);
    ELSE 
        UPDATE EMPLOYEE
        SET MONTHLY_SALARY = MONTHLY_SALARY+RAISE_AMOUNT
        WHERE EMP_ID = INPUT_ID;
        DBMS_OUTPUT.PUT_LINE('RAISE SUCCESSFULLY INCREASED BY '||RAISE_AMOUNT||'. NEW MONTLY SALARY FOR '||EMPLOYEE_NAME||' IS '||(CURRENT_SALARY+RAISE_AMOUNT));
    END IF;
END;
/

BEGIN
    GIVE_RAISE(6, 1000);
END;
/

------------------------------------------
-- CREATE AN INDEX
------------------------------------------

-- CREATING AN INDEX ON THE EMPLOYEE'S NAME COLUMN
CREATE INDEX IDX_NAME
ON EMPLOYEE(EMP_NAME);

DROP INDEX IDX_NAME;

------------------------------------------
-- WORKING WITH SEQUENCES AND TRIGGERS
------------------------------------------

CREATE SEQUENCE SQ_DEPARTMENT_PK
START WITH 8
INCREMENT BY 1;

-- CREATE A TRIGGER WHICH USES THIS SEQUENCE TO GENERATE PK
CREATE OR REPLACE TRIGGER TR_INSERT_DEPARTMENT
BEFORE INSERT ON DEPARTMENT
FOR EACH ROW
BEGIN 
    SELECT SQ_DEPARTMENT_PK.NEXTVAL INTO :NEW.DEPT_ID FROM DUAL;
END;
/

INSERT INTO DEPARTMENT (DEPT_NAME, MONTHLY_BUDGET) VALUES ('ANOTHER DEPARTMENT', 15000);
INSERT INTO DEPARTMENT (DEPT_NAME, MONTHLY_BUDGET) VALUES ('YET ANOTHER DEPARTMENT', 14000);

